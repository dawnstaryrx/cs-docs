---
sidebar_position: 10
---

# 九瑞科技面试

## 一、Get、Post、Put请求

1 Get和Post的区别？

| 对比项   | GET                                       | POST                                   |
| -------- | ----------------------------------------- | -------------------------------------- |
| 语义     | 从服务器**获取资源**                      | 向服务器**提交数据**，通常用于新增资源 |
| 参数位置 | 一般放在 URL 的 `?` 后面（查询字符串）    | 一般放在请求体中                       |
| 参数长度 | 有长度限制（浏览器和服务器限制 URL 长度） | 理论上无长度限制                       |
| 安全性   | 参数暴露在 URL 中，不适合敏感信息         | 参数在请求体中，相对安全               |
| 缓存     | 浏览器会缓存 GET 请求                     | POST 默认不会被缓存                    |
| 幂等性   | 幂等（多次请求效果一致）                  | 非幂等（多次提交可能产生多个资源）     |
| 适用场景 | 查询数据                                  | 提交表单、新增数据                     |

2 Get有请求体吗？

理论上 GET 请求可以携带请求体，但在实际开发中浏览器和服务器普遍忽略 GET 请求体，所以不推荐在 GET 中传递请求体参数。实际开发中我们一般用 GET + 查询字符串传递参数。

3 Get/Post/Put是否有幂等性？

| 方法 | 是否幂等 | 说明                                                         |
| ---- | -------- | ------------------------------------------------------------ |
| GET  | ✅ 幂等   | 多次请求不会改变资源状态，比如多次查询同一个用户信息。       |
| POST | ❌ 非幂等 | 每次请求可能创建一个新资源，比如多次提交订单会创建多个订单。 |
| PUT  | ✅ 幂等   | 多次请求结果相同，比如多次修改用户信息，最后资源状态一致。   |

📌 **总结：**

- 幂等性指的是同样的操作执行一次或多次，结果一致。
- 幂等性与是否有副作用是不同的概念（例如 DELETE 也可以是幂等的）。

## 二、Spring事务

添加try catch能否保证事务？

答案：❌ **不能**。

**原因：**

- Spring 的事务是通过 AOP 代理和 `@Transactional` 注解来实现的。
- 默认情况下，Spring 只在遇到 **运行时异常（RuntimeException）或 Error** 时才会回滚事务。
- 如果你在 `try...catch` 中捕获了异常并不再抛出，Spring 事务就**感知不到异常**，事务不会回滚，而会正常提交。

✅ **正确做法**：

- 不捕获异常，让 Spring 感知异常自动回滚。
- 或者在 catch 中手动回滚，例如：

```
@Transactional
public void updateData() {
    try {
        // 业务逻辑
    } catch (Exception e) {
        TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();
        throw e; // 或者重新抛出
    }
}
```

也可以通过 `@Transactional(rollbackFor = Exception.class)` 指定非运行时异常也回滚。

## 三、索引

1 项目中用过哪些索引？

| 索引类型 | 场景示例               | 说明                               |
| -------- | ---------------------- | ---------------------------------- |
| 主键索引 | `id` 主键              | 唯一标识记录，自动创建 B+Tree 索引 |
| 唯一索引 | `username` 唯一        | 保证字段唯一性                     |
| 普通索引 | `create_time` 查询     | 提升查询速度                       |
| 联合索引 | `(user_id, status)`    | 组合多个字段提高联合查询效率       |
| 全文索引 | `title`/`content` 搜索 | 适合搜索类场景（如文章检索）       |
| 前缀索引 | 针对字符串前部分       | 减少索引大小，提升性能             |

2 独立索引和联合索引的区别？

| 类型     | 定义                                     | 查询场景                 | 使用规则           |
| -------- | ---------------------------------------- | ------------------------ | ------------------ |
| 独立索引 | 对单个字段建立索引                       | 查询条件只涉及单一字段时 | 只能加速单字段查询 |
| 联合索引 | 对多个字段一起建立索引（例如 `(a,b,c)`） | 多字段组合查询时更高效   | 遵循“最左前缀原则” |

📌 **最左前缀原则**：

- 联合索引 `(a,b,c)` 可以命中以下查询：
  - ✅ `where a=...`
  - ✅ `where a=... and b=...`
  - ✅ `where a=... and b=... and c=...`
  - ❌ `where b=...`（不能跳过最左列）

✅ **建议：**

- 如果多列经常一起查询，优先考虑联合索引。
- 如果查询独立性较强，考虑单列索引。
- 避免重复或冗余索引。
