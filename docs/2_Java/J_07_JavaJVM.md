---
sidebar_position: 7
---

# Java-JVM

## 一、JVM组成

### 1. 什么是程序计数器？

线程私有的，每个线程一份，内部保存字节码的行号。用于记录正在执行的字节码指令的地址。

### 2. 你能详细介绍Java堆吗？

- 线程共享的区域：主要用来保存对象实例，数组等，内存不够则抛出OutOfMemoryError异常。
- 组成：年轻代+老年代
  - 年轻代被划分为三部分，Eden区和两个大小严格相同的Survivor区
  - 老年代主要保存生命周期长的对象，一般是一些老的对象
- JDK7和8的区别
  - 7中有一个永久代，存储的是类信息、静态变量、常量、编译后的代码
  - 8移除了永久代，把数据存储到了本地内存的元空间中，防止内存溢出

### 3. 什么是虚拟机栈？

- 每个线程运行时所需要的内存，称为虚拟机栈，先进后出
- 每个栈由多个栈帧组成，对应着每次方法调用时所占用的内存
- 每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法

#### 3.1 垃圾回收是否涉及栈内存？

垃圾回收主要指的是堆内存，当栈帧弹栈以后，内存就会释放

#### 3.2 栈内存分配越大越好吗？

未必，默认的栈内存通常为1024k，栈帧过大会导致线程数变少。例如，机器总内存为512m，目前能活动的线程数则为512个，如果把栈内存改为2048k，那么能活动的栈帧就会减半。

#### 3.3 方法内的局部变量是否线程安全？

- 如果方法内局部变量没有逃离方法的作用范围，它是线程安全的
- 如果是局部变量引用了对象，并逃离方法的作用范围，需要考虑线程安全

#### 3.4 栈内存溢出的情况

- 栈帧过多导致栈内存溢出，典型问题：递归调用
- 栈帧过大导致栈内存溢出

#### 3.5 堆栈的区别是什么？

- 栈内存一般用来存储局部变量和方法调用，但堆内存是用来存储Java对象和数组。
- 堆会垃圾回收，栈不会。
- 栈内存是线程私有的，而堆内存是线程共有的。
- 两者异常错误不同，但如果栈内存或者堆内存不足都会抛出异常
  - 栈空间不足：java.lang.StackOverFlowError
  - 堆空间不足：java.lang.OutOfMemoryError

### 4. 能不能解释方法区？

- 方法区是各个线程共享的内存区域
- 主要存储类的信息、运行时常量池
- 虚拟机启动的时候创建，关闭虚拟机时释放
- 如果方法区域中的内存无法满足分配请求，则会抛出OutOfMemoryError:Metaspace

### 5. 介绍一下运行时常量池？

- 常量池可以看作是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等信息
- 当类被加载，它的常量池信息就会放入运行时常量池，并把里面的符号地址变为真实地址

### 6. 你听过直接内存吗？

- 直接内存并不属于JVM中的内存结构，不由JVM进行管理。是虚拟机的系统内存。
- 常见于NIO操作时，用于数据缓冲区，分配回收成本较高，但读写性能好，不受JVM内存回收管理。

## 二、类加载器

### 1. 什么是类加载器？类加载器有哪些？

- JVM只会运行二进制文件，类加载器的作用就是将字节码文件加载到JVM中，从而让Java程序能够启动起来。
- 类加载器分为：
  - 启动类加载器：加载JAVA_HOME/jre/lib目录下的库
  - 扩展类加载器：加载JAVA_HOME/jre/lib/ext目录下的类
  - 应用类加载器：用于加载classPath下的类
  - 自定义类加载器

### 2. 什么是双亲委派模型？

- 加载某一个类，先委托上一级的加载器进行加载，如果上级加载器也有上级，则会继续向上委托。如果该类委托上级没有被加载，子加载器才会尝试加载该类。
- 好处
  - 通过双亲委派机制可以避免某一个类被重复加载，当父类已经加载后则无需重复加载，保证唯一性。
  - 为了安全，保证类库API不会被修改。

### 3. 说一下类装载的执行过程

- 加载：查找和导入class文件
- 验证：保证加载类的准确性
- 准备：为类变量分配内存并设置类变量初始值
- 解析：把类中的符号引用转换为直接引用
- 初始化：对类的静态变量，静态代码块执行初始化操作
- 使用：JVM开始从入口方法开始执行用户的程序代码
- 卸载：当用户程序代码执行完毕后，JVM便开始销毁创建的Class对象

## 三、垃圾回收

### 1. 对象什么时候可以被垃圾回收器回收？

如果一个或多个对象没有任何引用指向它了，那么这个对象现在就是垃圾，如果定位了垃圾，则有可能会被垃圾回收器回收。

定位垃圾的方式有两种：

- 引用计数法
  - 当对象间出现了循环引用，则引用计数法会失效
- 可达性分析算法
  - Java虚拟机中的垃圾回收器采用可达性分析来探索所有存活的对象
  - 扫描堆中的对象，看是否能够沿着GC Root对象为起点的引用链找到该对象，找不到，表示可以回收

### 2. JVM垃圾回收算法有哪些？

- 标记清除算法：
  - 垃圾回收分为两个阶段，分别是标记和清除。
  - 效率高，有磁盘碎片，内存不连续。
- 标记整理算法：
  - 和标记清除算法一样，会将存活对象向内存一端移动，然后清理边界以外的垃圾。
  - 无碎片，对象需要移动，效率低。
- 复制算法：
  - 将原有的内存空间一分为二，每次只用其中的一块，正在使用的对象复制到另一个内存碎片中，然后将该内存空间清空，交换两个内存的角色，完成垃圾的回收。
  - 无碎片，内存使用率低。

### 3. 说一下JVM中的分代回收？

1. 堆的区域划分
   1. 堆被分了两份：新生代和老年代【1：2】
   2. 对于新生代，内部又被分为了三个区域。Eden区、Survivor区（分为From和To）【8：1：1】
2. 对象回收分代回收策略
   1. 新创建的对象，都会先分配到Eden区
   2. 当Eden区内存不足，标记Eden与From的存活对象
   3. 将存活对象采用复制算法复制到To中，复制完毕后，Eden与From的内存都得到释放
   4. 经过一段时间后Eden的内存又出现不足，标记Eden区To区存活的对象，将其复制到From区
   5. 当幸存区对象熬过几次回收（最多15次），晋升到老年代（幸存区内存不足或大内存会提前晋升）

### 4. MinorGC、MixedGC、FullFC的区别是什么

- MinorGC发生在新生代的垃圾回收，暂停时间短（STW）
- MixedGC新生代+老年代部分区域的垃圾回收，G1收集器特有
- FullGC：新生代+老年代完整垃圾回收，暂停时间长（STW），应尽力避免

### 5. 说一下JVM的垃圾回收器

在JVM中，实现了多种垃圾收集器，包括：

- 串行垃圾收集器：Serial GC, Serial Old GC
- 并行垃圾收集器：Parallel Old GC, ParNew GC
- CMS（并发）垃圾收集器：CMS GC, 作用在老年代
- G1垃圾收集器：作用在新生代和老年代

### 6. 详细说一下G1垃圾回收器

- 应用于新生代和老年代，在JDK9之后默认使用G1
- 划分成多个区域，每个区域都可以充当eden，survivor，old，humongous，其中humongous专为大对象准备
- 采用复制算法
- 响应时间与吞吐量兼顾
- 分成三个阶段：新生代回收(stw)、并发标记(重新标记stw)、混合收集
- 如果并发失败（即回收速度赶不上创建新对速度），会触发FullGC

### 7. 强引用、软引用、弱引用、虚引用的区别

- 强引用：只要所有GC Roots能找到，就不会被回收
- 软引用：需要配合SoftReference使用，当垃圾多次回收，内存依然不够的时候会回收软引用对象
- 弱引用：需要配合WeakReference使用，只要进行了垃圾回收，就会把弱引用对象回收
- 虚引用：必须配合引用队列使用，被引用对象回收时，会将虚引用入队，由Reference Handler线程调用虚引用相关方法释放直接内存

| 引用类型 | 是否参与GC判断 | 被回收时机           | 应用场景               |
| -------- | -------------- | -------------------- | ---------------------- |
| 强引用   | 否             | 永远不会被回收       | 常规对象               |
| 软引用   | 是             | 内存不足时被回收     | 缓存                   |
| 弱引用   | 是             | 下一次 GC 时回收     | ThreadLocal、缓存清理  |
| 虚引用   | 是             | 回收前被加入队列通知 | 资源释放通知、堆外内存 |

## 四、JVM实践

### 1. JVM调优的参数可以在哪里设置参数值？

Jar包部署在启动参数设置。

### 2. JVM调优的参数有哪些？

对于JVM调优，主要就是调整年轻代、老年代、元空间的内存空间大小及使用的垃圾回收器类型。

- 设置堆空间大小 -Xms 初始大小 -Xmx 最大大小
- 虚拟机栈的设置 -Xss
- 年轻代中Eden区和两个Survivor区的大小比例
- 年轻代晋升老年代的阈值
- 设置垃圾回收器类型

### 3. 说一下JVM调优工具

- 命令工具
  - jps         进程状态信息
  - jstack    查看java进程内线程的堆栈信息
  - jmap     查看堆转信息
  - jhat       堆转储快照分析工具
  - jstat      JVM统计监测工具
- 可视化工具
  - jconsole     用于对JVM的内存、线程、类的监控
  - ViaualVM   能够监控线程，内存情况

