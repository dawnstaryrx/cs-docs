---
sidebar_position: 7
---

# Java-JVM

## 一、JVM组成

### 1. 什么是程序计数器？

线程私有的，每个线程一份，内部保存字节码的行号。用于记录正在执行的字节码指令的地址。

### 2. 你能详细介绍Java堆吗？

- 线程共享的区域：主要用来保存对象实例，数组等，内存不够则抛出OutOfMemoryError异常。
- 组成：年轻代+老年代
  - 年轻代被划分为三部分，Eden区和两个大小严格相同的Survivor区
  - 老年代主要保存生命周期长的对象，一般是一些老的对象
- JDK7和8的区别
  - 7中有一个永久代，存储的是类信息、静态变量、常量、编译后的代码
  - 8移除了永久代，把数据存储到了本地内存的元空间中，防止内存溢出

### 3. 什么是虚拟机栈？

- 每个线程运行时所需要的内存，称为虚拟机栈，先进后出
- 每个栈由多个栈帧组成，对应着每次方法调用时所占用的内存
- 每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法

#### 3.1 垃圾回收是否涉及栈内存？

垃圾回收主要指的是堆内存，当栈帧弹栈以后，内存就会释放

#### 3.2 栈内存分配越大越好吗？

未必，默认的栈内存通常为1024k，栈帧过大会导致线程数变少。例如，机器总内存为512m，目前能活动的线程数则为512个，如果把栈内存改为2048k，那么能活动的栈帧就会减半。

#### 3.3 方法内的局部变量是否线程安全？

- 如果方法内局部变量没有逃离方法的作用范围，它是线程安全的
- 如果是局部变量引用了对象，并逃离方法的作用范围，需要考虑线程安全

#### 3.4 栈内存溢出的情况

- 栈帧过多导致栈内存溢出，典型问题：递归调用
- 栈帧过大导致栈内存溢出

#### 3.5 堆栈的区别是什么？

- 栈内存一般用来存储局部变量和方法调用，但堆内存是用来存储Java对象和数组。
- 堆会垃圾回收，栈不会。
- 栈内存是线程私有的，而堆内存是线程共有的。
- 两者异常错误不同，但如果栈内存或者堆内存不足都会抛出异常
  - 栈空间不足：java.lang.StackOverFlowError
  - 堆空间不足：java.lang.OutOfMemoryError

### 4. 能不能解释方法区？

- 方法区是各个线程共享的内存区域
- 主要存储类的信息、运行时常量池
- 虚拟机启动的时候创建，关闭虚拟机时释放
- 如果方法区域中的内存无法满足分配请求，则会抛出OutOfMemoryError:Metaspace

### 5. 介绍一下运行时常量池？

- 常量池可以看作是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等信息
- 当类被加载，它的常量池信息就会放入运行时常量池，并把里面的符号地址变为真实地址

### 6. 你听过直接内存吗？

- 直接内存并不属于JVM中的内存结构，不由JVM进行管理。是虚拟机的系统内存。
- 常见于NIO操作时，用于数据缓冲区，分配回收成本较高，但读写性能好，不受JVM内存回收管理。

## 二、类加载器

### 1. 什么是类加载器？类加载器有哪些？

- JVM只会运行二进制文件，类加载器的作用就是将字节码文件加载到JVM中，从而让Java程序能够启动起来。
- 类加载器分为：
  - 启动类加载器：加载JAVA_HOME/jre/lib目录下的库
  - 扩展类加载器：加载JAVA_HOME/jre/lib/ext目录下的类
  - 应用类加载器：用于加载classPath下的类
  - 自定义类加载器

### 2. 什么是双亲委派模型？

- 加载某一个类，先委托上一级的加载器进行加载，如果上级加载器也有上级，则会继续向上委托。如果该类委托上级没有被加载，子加载器才会尝试加载该类。
- 好处
  - 通过双亲委派机制可以避免某一个类被重复加载，当父类已经加载后则无需重复加载，保证唯一性。
  - 为了安全，保证类库API不会被修改。

### 3. 说一下类装载的执行过程

- 加载：查找和导入class文件
- 验证：保证加载类的准确性
- 准备：为类变量分配内存并设置类变量初始值
- 解析：把类中的符号引用转换为直接引用
- 初始化：对类的静态变量，静态代码块执行初始化操作
- 使用：JVM开始从入口方法开始执行用户的程序代码
- 卸载：当用户程序代码执行完毕后，JVM便开始销毁创建的Class对象

## 三、垃圾回收



## 四、JVM实践



